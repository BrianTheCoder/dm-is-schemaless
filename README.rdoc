= DM - Is - Schemaless

So after reading this article,http://bret.appspot.com/entry/how-friendfeed-uses-mysql, I thought to myself, "Hey that's pretty sweet, I wonder if I can do that in DataMapper" I started on the project, realized I could and then lost interested because I had no real need for it. Then yesterday(May 7th) I realized it fit a problem perfectly, so I finished it.

== What is this shit?

Good question. I like audience participation. So basically you have your class like this

  class Message
    include DataMapper::Resource
  
    is :schemaless
  end

What that does is set your model to be stored in a table called "entites", which is where all good schemaless models are stored. It also adds these fields:

  property :added_id, DataMapper::Types::Serial, :key => false
  property :id, String, :unique => true, :nullable => false
  property :updated, DataMapper::Types::EpochTime, :key => true
  property :body, DataMapper::Types::Json
  
The id field is a uuid string generated by the model. The added_id field is just there as an auto incrementer for the database. A Json field is really a text field just being loaded and dumped. So the basic idea is you through stuff into the body field and then create indexes on that data and query the model that way.

==Indexes

So what's an index. In this context an index is a table with two values, the record id(a uuid string) and the value you're indexing.

===How does it work
  
  class Message
    include DataMapper::Resource

    is :schemaless

    index_on :email
  end
  
This will create the necessary index and handle the creating and updating of the index. It will also delete the index if the value is removed from the body.

===Querying

This is handled forward. Once you index a value you can treat it like it was a property on the model when querying. So with the above model I can do:
  
  Message.all(:email.like => "%gmail.com", :limit => 1)
  
What happens, is dm-is-schemaless overrides all and first and intercepts the queries. If you use an indexed field the query is transformed. So in the above example. :email.like is transformed to "email_index.email.like". Easy peasy.
  
===Hooks 

So lets say you want to controll how your index is created, updated, or destroyed. Well for each index a method is defined on the model called update_#{field}_index, where field is the value being indexed. So in the above example the method is update_email_index. Override it and add your own custom logic. Say for example you have a field that is an array of tags. You may change the default behavior from this for email:

  def update_email_index
    #wipe old index
    old = EmailIndex.first(:message_id => id)
    old.destroy unless old.nil?
    if body.has_key?("email")
      EmailIndex.create(:message_id => id, :email => body["email"])
    end
  end

to something like this for tags

  #assuming you defined index_on :tag

  def update_tag_index
    # wipe old tags
    TagIndex.all(:message_id => id).each{|t| t.destroy}
    body["tags"].each do |tag|
      TagIndex.create(:message_id => id, :tag => t)
    end
  end

==Wrap Up

That's pretty much it. Open to suggestions, comments, beer, etc.

Hit me at wbsmith@gmail.com or @brianthecoder